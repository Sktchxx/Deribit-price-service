# Crypto Price Collector (Deribit)

Тестовое задание на позицию Junior Backend Developer.

Сервис предназначен для периодического получения index price криптовалют BTC/USD и ETH/USD с биржи Deribit, сохранения данных в PostgreSQL и предоставления HTTP API для их получения.

---

## Описание задачи

Приложение выполняет следующие функции:

- Каждую минуту получает текущую цену (index price) для `btc_usd` и `eth_usd`
- Сохраняет данные в PostgreSQL:
  - тикер валюты
  - цену
  - время в формате UNIX timestamp
- Предоставляет HTTP API на FastAPI для работы с сохранёнными данными

---

## Функциональность API

Все методы используют HTTP GET и принимают обязательный query-параметр `ticker`.

Реализованы следующие методы:

- Получение всех сохранённых данных по валюте
- Получение последней цены валюты
- Получение цены валюты за указанный период времени

---

## Используемые технологии

- Python 3.12
- FastAPI
- PostgreSQL
- SQLAlchemy (async и sync)
- Celery
- Celery Beat
- Redis
- aiohttp
- Docker
- Docker Compose
- Alembic
- Pytest

---

## Архитектура проекта

Проект построен с разделением ответственности между слоями.

```
app/
├── api/              HTTP API (роутеры, схемы)
├── core/             Конфигурация приложения
├── db/               Работа с БД (engine, session, models)
├── repositories/     Слой доступа к данным
├── services/         Бизнес-логика
├── tasks.py          Celery-задачи
├── celery_app.py     Конфигурация Celery
└── main.py           Точка входа FastAPI
```

---

## Переменные окружения

Настройки приложения задаются через файл `.env` либо используются значения по умолчанию.

```
POSTGRES_USER=user
POSTGRES_PASSWORD=pass
POSTGRES_DB=prices
POSTGRES_HOST=db
POSTGRES_PORT=5432

REDIS_HOST=redis
REDIS_PORT=6379
```

---

## Запуск проекта

### Клонирование репозитория

```
git clone <repository_url>
cd project
```

### Запуск через Docker Compose

```
docker compose up --build
```

После запуска будут подняты следующие сервисы:

- FastAPI приложение — http://localhost:8000
- PostgreSQL
- Redis
- Celery worker
- Celery Beat

---

## Документация API

Swagger-документация доступна по адресу:

http://localhost:8000/docs

---

## Примеры запросов

### Получение последней цены валюты

```
GET /prices/latest?ticker=btc_usd
```

### Получение всех цен валюты

```
GET /prices/all?ticker=eth_usd
```

### Получение цен за период времени

```
GET /prices/range?ticker=btc_usd&from_ts=1705708800&to_ts=1705712400
```

Параметры `from_ts` и `to_ts` передаются в формате UNIX timestamp (секунды).

---

## Работа с базой данных

### Применение миграций

```
docker compose exec app alembic upgrade head
```

### Проверка сохранённых данных

```
docker compose exec db psql -U user -d prices
```

```
SELECT * FROM prices ORDER BY timestamp DESC;
```

---

## Тестирование

Для основных сервисных методов реализованы unit-тесты с использованием моков.

Запуск тестов:

```
pytest
```

---

## Design decisions

### Выбор архитектуры (Clean-ish architecture)

При проектировании приложения я сознательно разделил код на слои: API, Services, Repositories, DB и Background tasks. Такое разделение было выбрано по следующим причинам:

- **Предсказуемость** — каждый слой решает строго свою задачу
- **Тестируемость** — бизнес-логика изолирована от FastAPI и БД
- **Расширяемость** — при добавлении новых источников цен или новых API-методов не требуется переписывать существующий код

Хотя для тестового задания это избыточно, я считаю важным сразу придерживаться практик, которые используются в реальных backend-проектах.

---

### Repository + Service слой

Я намеренно вынес работу с БД в Repository слой, а бизнес-логику — в Service слой:

- **Repository** отвечает только за SQL-запросы и возвращает ORM-модели
- **Service** отвечает за правила обработки данных и преобразование их в DTO (Pydantic-схемы)

Такой подход позволил:

- писать unit-тесты без реальной БД (через моки)
- не смешивать SQLAlchemy и FastAPI
- избежать дублирования логики

---

### Sync и Async SQLAlchemy

В проекте используются **две отдельные точки доступа к БД**:

- `AsyncSession` — для FastAPI
- `Session` (sync) — для Celery

Причины такого решения:

- Celery не работает внутри event loop FastAPI
- Использование async SQLAlchemy в Celery усложняет код и повышает риск ошибок
- Sync SQLAlchemy проще и стабильнее для фоновых задач

Разделение URL (`DATABASE_ASYNC_URL` и `DATABASE_SYNC_URL`) позволяет явно контролировать контекст использования БД и избегать скрытых ошибок.

---

### Использование Celery + Celery Beat

Для периодического сбора цен был выбран Celery по следующим причинам:

- выполнение задач вне HTTP-запросов
- независимость от жизненного цикла FastAPI
- масштабируемость (при необходимости можно добавить воркеры)

Celery Beat используется исключительно для расписания (каждую минуту), что соответствует реальным production-сценариям.

---

### Клиент Deribit

Клиент биржи вынесен в отдельный класс `DeribitClient`.

Причины:

- единая точка для работы с внешним API
- простота мокирования в тестах
- возможность заменить Deribit на другой источник без изменений остального кода

Асинхронная версия клиента реализована через `aiohttp`, так как:

- он нативно работает с asyncio
- минимальные накладные расходы
- стандарт де-факто для async HTTP в Python

Синхронная версия используется только внутри Celery-задач.

---

### Формат времени — UNIX timestamp

Для хранения времени используется UNIX timestamp (секунды).

Причины:

- простота хранения и сравнения
- отсутствие проблем с timezone
- удобство фильтрации диапазонов
- формат часто используется в финансовых и биржевых API

Преобразование в человекочитаемую дату может выполняться на стороне клиента.

---

### Docker и Docker Compose

Приложение разворачивается через Docker Compose с отдельными контейнерами:

- FastAPI
- PostgreSQL
- Redis
- Celery Worker
- Celery Beat

Такой подход:

- упрощает локальный запуск
- воспроизводим на любой машине
- приближен к реальным условиям деплоя

---

### Unit-тестирование

Unit-тесты написаны только для основных сервисных методов.

Фокус сделан именно на Service-слое, потому что:

- он содержит бизнес-логику
- не зависит от FastAPI и БД
- легко тестируется через моки репозиториев

Это позволяет быстро проверять корректность логики без сложной инфраструктуры.

---

### Автор и связь

Tg:@sktch1337 Github /Sktchxx



